import CryptoJS from "npm:crypto-js";
import * as curve25519 from "npm:curve25519-js";
import * as crypto from "node:crypto";
import * as thrift from "npm:thrift@0.20.0";
import { Buffer } from "node:buffer";
import { Client } from "../../packages/client/index.ts";
const Thrift = thrift.Thrift;

// auto-generated by chatGPT

class E2EE extends Client {
	async getE2EESelfKeyData(mid) {
		try {
			return JSON.parse(this.storage.get("e2eeKeys:" + mid));
		} catch (e) {
		}
		const keys = await this.getE2EEPublicKeys();
		for (let i = 0; i < keys.length; i++) {
			const key = keys[i];
			const { keyId } = key;
			const _keyData = this.getE2EESelfKeyDataByKeyId(keyId);
			if (_keyData) return _keyData;
		}
		throw new Error(
			"E2EE Key has not been saved, try register or use SQR Login",
		);
	}
	getE2EESelfKeyDataByKeyId(keyId) {
		try {
			return JSON.parse(this.storage.get("e2eeKeys:" + keyId));
		} catch { }
	}
	saveE2EESelfKeyDataByKeyId(keyId, value) {
		this.storage.set("e2eeKeys:" + keyId, JSON.stringify(value));
	}
	getToType(mid) {
		/**
		 * USER(0),
		 * ROOM(1),
		 * GROUP(2),
		 * SQUARE(3),
		 * SQUARE_CHAT(4),
		 * SQUARE_MEMBER(5),
		 * BOT(6);
		 */
		const _u = mid.charAt(0);
		switch (_u) {
			case "u":
				return 0;
			case "r":
				return 1;
			case "c":
				return 2;
			case "s":
				return 3;
			case "m":
				return 4;
			case "p":
				return 5;
			case "v":
				return 6;
			default:
				return null; // 必要に応じてデフォルト値を追加
		}
	}
	async getE2EELocalPublicKey(mid, keyId) {
		const toType = this.getToType(mid);
		let key = undefined;
		let fd, fn;

		if (toType === 0) {
			fd = "e2eePublicKeys";
			fn = `:${keyId}`;
			if (keyId !== undefined) {
				key = this.storage.get(fd + fn);
			}
			let receiverKeyData;
			if (!key) {
				receiverKeyData = await this.negotiateE2EEPublicKey(mid);
				const specVersion = receiverKeyData.specVersion;
				if (specVersion === -1) {
					throw new Error(`Not support E2EE on ${mid}`);
				}
				const publicKey = receiverKeyData.publicKey;
				const receiverKeyId = publicKey.keyId;
				receiverKeyData = publicKey.keyData;
				if (receiverKeyId === keyId) {
					key = Buffer.from(receiverKeyData).toString("base64");
					this.storage.set(fd + fn, key);
				} else {
					throw new Error(
						`E2EE key id-${keyId} not found on ${mid}, key id should be ${receiverKeyId}`,
					);
				}
			}
		} else {
			fd = "e2eeGroupKeys";
			fn = `:${mid}`;
			key = this.storage.get(fd + fn);
			if (keyId !== undefined && key !== undefined) {
				const keyData = JSON.parse(key);
				if (keyId !== keyData["keyId"]) {
					this._log(`keyId mismatch: ${mid}`);
					key = undefined;
				}
			} else {
				key = undefined;
			}
			if (!key) {
				let E2EEGroupSharedKey = await this.getLastE2EEGroupSharedKey(2, mid);
				const groupKeyId = E2EEGroupSharedKey.groupKeyId;
				const creator = E2EEGroupSharedKey.creator;
				const creatorKeyId = E2EEGroupSharedKey.creatorKeyId;
				const receiver = E2EEGroupSharedKey.receiver;
				const receiverKeyId = E2EEGroupSharedKey.receiverKeyId;
				const encryptedSharedKey = E2EEGroupSharedKey.encryptedSharedKey;
				const selfKey = atob(
					this.getE2EESelfKeyDataByKeyId(receiverKeyId)["privKey"],
				);
				const creatorKey = await this.getE2EELocalPublicKey(
					creator,
					creatorKeyId,
				);
				const aesKey = this.generateSharedSecret(selfKey, creatorKey);
				const aes_key = this.getSHA256Sum(aesKey, "Key");
				const aes_iv = this._xor(this.getSHA256Sum(aesKey, "IV"));

				this._log({ aes_key, aes_iv, encryptedSharedKey });

				const cipherParams = CryptoJS.lib.CipherParams.create({
					ciphertext: (encryptedSharedKey.toString()),
					iv: (aes_iv.toString()),
					mode: CryptoJS.mode.CBC,
					padding: CryptoJS.pad.Pkcs7,
				});

				const plainText = CryptoJS.AES.decrypt(
					cipherParams,
					aes_key.toString(),
					{ mode: CryptoJS.mode.CBC },
				);

				this._log({ plainText });

				let decrypted = plainText.toString(CryptoJS.enc.Base64);
				this._log(`[getE2EELocalPublicKey] decrypted: ${decrypted}`, true);
				const data = {
					"privKey": decrypted,
					"keyId": groupKeyId,
				};
				key = JSON.stringify(data);
				this.storage.set(fd + fn, key);
			}
			return JSON.parse(key);
		}
		return Buffer.from(key, "base64");
	}

	generateSharedSecret(privateKey, publicKey) {
		this._log({ privateKey: privateKey.length, publicKey: publicKey.length });
		return curve25519.sharedKey(
			Uint8Array.from(privateKey),
			Uint8Array.from(publicKey),
		);
	}
	
	_encryptAESECB(aesKey, plainData) {
		const cipher = crypto.createCipheriv("aes-128-ecb", aesKey, null);
		cipher.setAutoPadding(false);
		return Buffer.concat([cipher.update(plainData), cipher.final()]);
	}

	decryptKeyChain(publicKey, privateKey, encryptedKeyChain) {
		const sharedSecret = this.generateSharedSecret(privateKey, publicKey);
		const aesKey = this.getSHA256Sum(sharedSecret, "Key");
		const aesIv = this._xor(this.getSHA256Sum(sharedSecret, "IV"));
		const decipher = crypto.createDecipheriv("aes-128-cbc", aesKey, aesIv);
		let keychainData = Buffer.concat([
			decipher.update(encryptedKeyChain),
			decipher.final(),
		]);
		let key = keychainData.toString("hex");
		key = bin2bytes(key);
		const tc = new TCompactProtocol(key);
		key = tc.readStruct()[1];
		const publicKeyBytes = Buffer.from(key[0][4]);
		const privateKeyBytes = Buffer.from(key[0][5]);
		return [privateKeyBytes, publicKeyBytes];
	}

	encryptDeviceSecret(publicKey, privateKey, encryptedKeyChain) {
		const sharedSecret = this.generateSharedSecret(privateKey, publicKey);
		const aesKey = this.getSHA256Sum(sharedSecret, "Key");
		encryptedKeyChain = this._xor(this.getSHA256Sum(encryptedKeyChain));
		const cipher = crypto.createCipheriv("aes-128-ecb", aesKey, null);
		cipher.setAutoPadding(false);
		const keychainData = Buffer.concat([
			cipher.update(encryptedKeyChain),
			cipher.final(),
		]);
		return keychainData;
	}

	generateAAD(a, b, c, d, e = 2, f = 0) {
		let aad = Buffer.alloc(0);
		aad = Buffer.concat([aad, Buffer.from(a)]);
		aad = Buffer.concat([aad, Buffer.from(b)]);
		aad = Buffer.concat([aad, this.getIntBytes(c)]);
		aad = Buffer.concat([aad, this.getIntBytes(d)]);
		aad = Buffer.concat([aad, this.getIntBytes(e)]);
		aad = Buffer.concat([aad, this.getIntBytes(f)]);
		return aad;
	}
	getIntBytes(i) {
		const j = 4;
		i = parseInt(i, 10);
		let res;

		if (j ** 2 === 16) {
			const buffer = new ArrayBuffer(4);
			const view = new DataView(buffer);
			view.setInt32(0, i);
			res = new Uint8Array(buffer);
		} else {
			const buffer = new ArrayBuffer(8);
			const view = new DataView(buffer);
			view.setBigInt64(0, BigInt(i));
			res = new Uint8Array(buffer);
		}

		return res;
	}
	getSHA256Sum(...args) {
		const hash = crypto.createHash("sha256");
		for (let arg of args) {
			if (typeof arg === "string") {
				arg = Buffer.from(arg);
			}
			hash.update(arg);
		}
		return hash.digest();
	}

	_xor(buf) {
		const bufLength = Math.floor(buf.length / 2);
		const buf2 = Buffer.alloc(bufLength);
		for (let i = 0; i < bufLength; i++) {
			buf2[i] = buf[i] ^ buf[bufLength + i];
		}
		return buf2;
	}

	async encryptE2EEMessage(
		to,
		text,
		specVersion = 2,
		isCompact = false,
		contentType = 0,
	) {
		const _from = this.mid;
		const selfKeyData = await this.getE2EESelfKeyData(_from);

		if (to.length === 0 || ![0, 1, 2].includes(this.getToType(to))) {
			throw new Error("Invalid mid");
		}

		const senderKeyId = selfKeyData.keyId;
		let receiverKeyId, keyData;

		if (this.getToType(to) === 0) {
			const privateKey = Buffer.from(selfKeyData.privKey, "base64");
			const receiverKeyData = await this.negotiateE2EEPublicKey(to);
			specVersion = receiverKeyData.specVersion;

			if (specVersion === -1) {
				throw new Error(`Not support E2EE on ${to}`);
			}

			const publicKey = receiverKeyData.publicKey;
			receiverKeyId = publicKey.keyId;
			const receiverKeyDataBuffer = publicKey.keyData;
			keyData = this.generateSharedSecret(privateKey, receiverKeyDataBuffer);
		} else {
			const groupK = await this.getE2EELocalPublicKey(to, undefined);
			const privK = Buffer.from(groupK.privKey, "base64");
			const pubK = Buffer.from(selfKeyData.pubKey, "base64");
			receiverKeyId = groupK.keyId;
			keyData = this.generateSharedSecret(privK, pubK);
		}

		let chunks;
		if (contentType === 15) {
			chunks = this.encryptE2EELocationMessage(
				senderKeyId,
				receiverKeyId,
				keyData,
				specVersion,
				text,
				to,
				_from,
				isCompact,
			);
		} else {
			chunks = this.encryptE2EETextMessage(
				senderKeyId,
				receiverKeyId,
				keyData,
				specVersion,
				text,
				to,
				_from,
				isCompact,
			);
		}

		return chunks;
	}

	encryptE2EETextMessage(
		senderKeyId,
		receiverKeyId,
		keyData,
		specVersion,
		text,
		to,
		_from,
		isCompact = false,
	) {
		const salt = crypto.randomBytes(16);
		const gcmKey = this.getSHA256Sum(keyData, salt, Buffer.from("Key"));
		const aad = this.generateAAD(
			to,
			_from,
			senderKeyId,
			receiverKeyId,
			specVersion,
			0,
		);
		const sign = crypto.randomBytes(16);
		const data = Buffer.from(JSON.stringify({ text: text }));
		const encData = this.encryptE2EEMessageV2(data, gcmKey, sign, aad);

		let bSenderKeyId = Buffer.from(this.getIntBytes(senderKeyId));
		let bReceiverKeyId = Buffer.from(this.getIntBytes(receiverKeyId));

		if (isCompact) {
			const compactS = new TCompactProtocol();
			const compactR = new TCompactProtocol();
			compactS.writeI32(parseInt(senderKeyId));
			bSenderKeyId = compactS.buf;
			compactR.writeI32(parseInt(receiverKeyId));
			bReceiverKeyId = compactR.buf;
		}

		this._log(
			`senderKeyId: ${senderKeyId} (${bSenderKeyId.toString("hex")})`,
			true,
		);
		this._log(
			`receiverKeyId: ${receiverKeyId} (${bReceiverKeyId.toString("hex")})`,
			true,
		);

		return [salt, encData, sign, bSenderKeyId, bReceiverKeyId];
	}

	encryptE2EELocationMessage(
		senderKeyId,
		receiverKeyId,
		keyData,
		specVersion,
		location,
		to,
		_from,
		isCompact = false,
	) {
		const salt = crypto.randomBytes(16);
		const gcmKey = this.getSHA256Sum(keyData, salt, Buffer.from("Key"));
		const aad = this.generateAAD(
			to,
			_from,
			senderKeyId,
			receiverKeyId,
			specVersion,
			15,
		);
		const sign = crypto.randomBytes(16);
		const data = Buffer.from(JSON.stringify({ location: location }));
		const encData = this.encryptE2EEMessageV2(data, gcmKey, sign, aad);

		let bSenderKeyId = Buffer.from(this.getIntBytes(senderKeyId));
		let bReceiverKeyId = Buffer.from(this.getIntBytes(receiverKeyId));

		if (isCompact) {
			const compactS = new TCompactProtocol();
			const compactR = new TCompactProtocol();
			compactS.writeI32(parseInt(senderKeyId));
			bSenderKeyId = compactS.buf;
			compactR.writeI32(parseInt(receiverKeyId));
			bReceiverKeyId = compactR.buf;
		}

		this._log(
			`senderKeyId: ${senderKeyId} (${bSenderKeyId.toString("hex")})`,
			true,
		);
		this._log(
			`receiverKeyId: ${receiverKeyId} (${bReceiverKeyId.toString("hex")})`,
			true,
		);

		return [salt, encData, sign, bSenderKeyId, bReceiverKeyId];
	}

	encryptE2EEMessageV2(data, gcmKey, nonce, aad) {
		const cipher = crypto.createCipheriv("aes-256-gcm", gcmKey, nonce);
		cipher.setAAD(aad);
		const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);
		const tag = cipher.getAuthTag();
		return Buffer.concat([encrypted, tag]);
	}

	async decryptE2EETextMessage(messageObj, isSelf = true) {
		const _from = messageObj._from;
		const to = messageObj.to;
		const toType = messageObj.toType;
		const metadata = messageObj.contentMetadata;
		const specVersion = metadata.e2eeVersion || "2";
		const contentType = messageObj.contentType;
		let chunks = messageObj.chunks.map((chunk) =>
			typeof chunk === "string" ? Buffer.from(chunk, "utf-8") : chunk
		);
		const senderKeyId = byte2int(chunks[3]);
		const receiverKeyId = byte2int(chunks[4]);
		this._log(`senderKeyId: ${senderKeyId}`, true);
		this._log(`receiverKeyId: ${receiverKeyId}`, true);

		const selfKey = await this.getE2EESelfKeyData(this.user.mid);
		let privK = Buffer.from(selfKey.privKey, "base64");
		let pubK;

		if (toType === 0 || toType === "USER") {
			pubK = await this.getE2EELocalPublicKey(
				isSelf ? to : _from,
				isSelf ? receiverKeyId : senderKeyId,
			);
		} else {
			const groupK = await this.getE2EELocalPublicKey(to, receiverKeyId);
			privK = Buffer.from(groupK.privKey, "base64");
			pubK = Buffer.from(selfKey.pubKey, "base64");
			if (_from !== this.user.mid) {
				pubK = await this.getE2EELocalPublicKey(_from, senderKeyId);
			}
		}

		let decrypted;
		if (specVersion === "2") {
			decrypted = this.decryptE2EEMessageV2(
				to,
				_from,
				chunks,
				privK,
				pubK,
				specVersion,
				contentType,
			);
		} else {
			decrypted = this.decryptE2EEMessageV1(chunks, privK, pubK);
		}

		return decrypted.text || "";
	}

	async decryptE2EELocationMessage(messageObj, isSelf = true) {
		const _from = messageObj._from;
		const to = messageObj.to;
		const toType = messageObj.toType;
		const metadata = messageObj.contentMetadata;
		const specVersion = metadata.e2eeVersion || "2";
		const contentType = messageObj.contentType;
		let chunks = messageObj.chunks;

		chunks = chunks.map((chunk) =>
			typeof chunk === "string" ? Buffer.from(chunk, "utf-8") : chunk
		);

		const senderKeyId = byte2int(chunks[3]);
		const receiverKeyId = byte2int(chunks[4]);
		this._log(`senderKeyId: ${senderKeyId}`, true);
		this._log(`receiverKeyId: ${receiverKeyId}`, true);

		const selfKey = await this.getE2EESelfKeyData(this.mid);
		let privK = Buffer.from(selfKey.privKey, "base64");
		let pubK;

		if (toType === 0 || toType === "USER") {
			pubK = await this.getE2EELocalPublicKey(
				to,
				isSelf ? receiverKeyId : senderKeyId,
			);
		} else {
			const groupK = await this.getE2EELocalPublicKey(to, receiverKeyId);
			privK = Buffer.from(groupK.privKey, "base64");
			pubK = Buffer.from(selfKey.pubKey, "base64");
			if (_from !== this.mid) {
				pubK = await this.getE2EELocalPublicKey(_from, senderKeyId);
			}
		}

		let decrypted;
		if (specVersion === "2") {
			decrypted = this.decryptE2EEMessageV2(
				to,
				_from,
				chunks,
				privK,
				pubK,
				specVersion,
				contentType,
			);
		} else {
			decrypted = this.decryptE2EEMessageV1(chunks, privK, pubK);
		}

		return decrypted.location || undefined;
	}

	decryptE2EEMessageV1(chunks, privK, pubK) {
		const salt = chunks[0];
		const message = chunks[1];
		const sign = chunks[2];
		const aesKey = this.generateSharedSecret(privK, pubK);
		const aes_key = this.getSHA256Sum(aesKey, salt, Buffer.from("Key"));
		const aes_iv = this._xor(this.getSHA256Sum(aesKey, salt, "IV"));
		const decipher = crypto.createDecipheriv("aes-256-cbc", aes_key, aes_iv);
		let decrypted = Buffer.concat([decipher.update(message), decipher.final()]);
		this._log(`decrypted: ${decrypted.toString("utf-8")}`, true);
		decrypted = this.unpad(decrypted, 16);
		return JSON.parse(decrypted.toString("utf-8"));
	}

	decryptE2EEMessageV2(
		to,
		from,
		chunks,
		privK,
		pubK,
		specVersion = 2,
		contentType = 0,
	) {
		const salt = chunks[0];
		const message = chunks[1];
		const ciphertext = message.subarray(0, -16);
		const tag = message.subarray(-16);
		const sign = chunks[2];
		const senderKeyId = byte2int(chunks[3]);
		const receiverKeyId = byte2int(chunks[4]);
		const aesKey = this.generateSharedSecret(privK, pubK);
		const gcmKey = this.getSHA256Sum(aesKey, salt, "Key");
		const aad = this.generateAAD(
			to,
			from,
			senderKeyId,
			receiverKeyId,
			specVersion,
			contentType,
		);

		const decipher = crypto.createDecipheriv("aes-256-gcm", gcmKey, sign);
		decipher.setAuthTag(tag);
		decipher.setAAD(aad);
		let decrypted;
		try {
			decrypted = decipher.update(ciphertext);
			decrypted = Buffer.concat([decrypted, decipher.final()]);
		} catch (err) {
			this._log(`Decryption failed: ${err.message}`, true);
			throw err;
		}

		this._log(`decrypted: ${decrypted}`, true);
		return JSON.parse(decrypted.toString());
	}

	_log(str) {
		this.log("e2ee", { message: str });
	}

	// 任意の補助メソッドが含まれる場合に対応するため、`TCompactProtocol` や `bin2bytes`, `getIntBytes` メソッドの実装が必要です。
}

function byte2int(t) {
	let e = 0;
	const s = t.length;
	for (let i = 0; i < s; i++) {
		e = 256 * e + t[i];
	}
	return e;
}

function bin2bytes(k) {
	const e = [];
	for (let i = 0; i < k.length / 2; i++) {
		const _i = parseInt(k.substring(i * 2, i * 2 + 2), 16);
		e.push(_i);
	}
	return new Uint8Array(e);
}

class TCompactProtocol extends thrift.TCompactProtocol {
	constructor(data = new Uint8Array()) {
		let myBuf = Buffer.from(data);
		const buftra = new thrift.TBufferedTransport(myBuf, function (outBuf) {
			myBuf = Buffer.concat([myBuf, outBuf]);
		});
		super(buftra);
		this.buf = myBuf;
	}

	readStruct() {
		var returnData = {};
		this.readStructBegin();
		var ret, ftype, fid;
		while (true) {
			ret = this.readFieldBegin();
			ftype = ret.ftype;
			fid = ret.fid;
			if (ftype == Thrift.Type.STOP) {
				break;
			}
			returnData[fid] = readValue(ftype);
			this.readFieldEnd();
		}
		this.readStructEnd();
		return returnData;
	}
	readValue(ftype) {
		var Thrift = thrift.Thrift;
		if (ftype == Thrift.Type.STRUCT) {
			return readStruct(this);
		} else if (ftype == Thrift.Type.I32) {
			return this.readI32();
		} else if (ftype == Thrift.Type.I64) {
			return parseInt(this.readI64().buffer.toString("hex"), 16);
		} else if (ftype == Thrift.Type.STRING) {
			return this.readString();
		} else if (ftype == Thrift.Type.LIST) {
			let returnData = [];
			var _rtmp = this.readListBegin();
			var _size = _rtmp.size || 0;
			for (var _i = 0; _i < _size; ++_i) {
				var elem = undefined;
				elem = readValue(this, _rtmp.etype);
				returnData.push(elem);
			}
			this.readListEnd();
			return returnData;
		} else if (ftype == Thrift.Type.MAP) {
			let returnData = {};
			var _rtmp3384 = this.readMapBegin();
			var _size383 = _rtmp3384.size || 0;
			for (var _i385 = 0; _i385 < _size383; ++_i385) {
				var key386 = undefined;
				var val387 = undefined;
				key386 = readValue(this, _rtmp3384.ktype);
				val387 = readValue(this, _rtmp3384.vtype);
				returnData[key386] = val387;
			}
			this.readMapEnd();
			return returnData;
		} else if (ftype == Thrift.Type.BOOL) {
			return this.readBool();
		} else if (ftype == Thrift.Type.DOUBLE) {
			return this.readDouble();
		} else {
			this.skip(ftype);
			return;
		}
		this.skip(ftype);
	}
}

export { E2EE, TCompactProtocol };
